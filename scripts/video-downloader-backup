#!/bin/bash
# Sistema de Backup Autom√°tico para Video Downloader v3.0
# Autor: DreamCoder08

set -euo pipefail

# Configuraci√≥n
CONFIG_DIR="$HOME/.config/video-downloader"
BACKUP_DIR="$CONFIG_DIR/backups"
LOG_FILE="$CONFIG_DIR/logs/backup.log"
MAX_BACKUPS=30
ENCRYPTION_KEY="$CONFIG_DIR/.backup_key"

# Cargar configuraci√≥n
source "$CONFIG_DIR/config.conf" 2>/dev/null || true

# Colores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Funciones de logging
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

log_info() {
    log "[INFO] $1"
}

log_error() {
    log "[ERROR] $1"
}

log_success() {
    log "[SUCCESS] $1"
}

# Notificaciones
notify() {
    local title="$1"
    local message="$2"
    local icon="${3:-info}"
    
    if [[ "${NOTIFICATIONS_ENABLED:-true}" == "true" ]] && command -v notify-send &> /dev/null; then
        notify-send "$title" "$message" --icon="$icon" --urgency=normal
    fi
}

# Crear clave de encriptaci√≥n
generate_encryption_key() {
    if [[ ! -f "$ENCRYPTION_KEY" ]]; then
        openssl rand -base64 32 > "$ENCRYPTION_KEY"
        chmod 600 "$ENCRYPTION_KEY"
        log_info "Clave de encriptaci√≥n generada"
    fi
}

# Verificar integridad con checksums
generate_checksum() {
    local file="$1"
    local checksum_file="${file}.sha256"
    
    sha256sum "$file" > "$checksum_file"
    log_info "Checksum generado para $(basename "$file")"
}

verify_checksum() {
    local file="$1"
    local checksum_file="${file}.sha256"
    
    if [[ -f "$checksum_file" ]]; then
        if sha256sum -c "$checksum_file" &>/dev/null; then
            log_info "Checksum verificado para $(basename "$file")"
            return 0
        else
            log_error "Checksum inv√°lido para $(basename "$file")"
            return 1
        fi
    else
        log_error "Archivo de checksum no encontrado para $(basename "$file")"
        return 1
    fi
}

# Crear backup
create_backup() {
    local backup_type="${1:-manual}"
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_name="backup_${backup_type}_${timestamp}"
    local backup_file="$BACKUP_DIR/${backup_name}.tar.gz"
    local encrypted_backup="${backup_file}.enc"
    
    mkdir -p "$BACKUP_DIR"
    
    log_info "Iniciando backup tipo: $backup_type"
    
    # Crear lista de archivos a respaldar
    local temp_list="/tmp/backup_list_$$.txt"
    cat > "$temp_list" << EOF
config.conf
logs/
queue/
icons/
themes/
EOF
    
    # Crear backup
    if tar -czf "$backup_file" -C "$CONFIG_DIR" -T "$temp_list" 2>/dev/null; then
        log_success "Backup creado: $(basename "$backup_file")"
        
        # Generar checksum
        if [[ "${CHECKSUM_VALIDATION:-true}" == "true" ]]; then
            generate_checksum "$backup_file"
        fi
        
        # Encriptar si est√° habilitado
        if [[ "${ENCRYPT_BACKUPS:-false}" == "true" ]]; then
            encrypt_backup "$backup_file" "$encrypted_backup"
            rm -f "$backup_file"  # Eliminar versi√≥n no encriptada
            backup_file="$encrypted_backup"
        fi
        
        # Crear metadatos
        create_backup_metadata "$backup_file" "$backup_type" "$timestamp"
        
        # Limpiar archivos temporales
        rm -f "$temp_list"
        
        # Notificar √©xito
        notify "üíæ Backup Creado" "Backup completado exitosamente" "document-save"
        
        echo "$backup_file"
        return 0
    else
        log_error "Error creando backup"
        rm -f "$temp_list"
        notify "‚ùå Error de Backup" "Fallo al crear backup" "dialog-error"
        return 1
    fi
}

# Encriptar backup
encrypt_backup() {
    local input_file="$1"
    local output_file="$2"
    
    if [[ ! -f "$ENCRYPTION_KEY" ]]; then
        generate_encryption_key
    fi
    
    if openssl enc -aes-256-cbc -salt -in "$input_file" -out "$output_file" -pass file:"$ENCRYPTION_KEY" 2>/dev/null; then
        log_info "Backup encriptado: $(basename "$output_file")"
        return 0
    else
        log_error "Error encriptando backup"
        return 1
    fi
}

# Desencriptar backup
decrypt_backup() {
    local input_file="$1"
    local output_file="$2"
    
    if [[ ! -f "$ENCRYPTION_KEY" ]]; then
        log_error "Clave de encriptaci√≥n no encontrada"
        return 1
    fi
    
    if openssl enc -aes-256-cbc -d -in "$input_file" -out "$output_file" -pass file:"$ENCRYPTION_KEY" 2>/dev/null; then
        log_info "Backup desencriptado: $(basename "$output_file")"
        return 0
    else
        log_error "Error desencriptando backup (clave inv√°lida?)"
        return 1
    fi
}

# Crear metadatos del backup
create_backup_metadata() {
    local backup_file="$1"
    local backup_type="$2"
    local timestamp="$3"
    local metadata_file="${backup_file}.json"
    
    local file_size=$(stat -c%s "$backup_file" 2>/dev/null || echo "0")
    local file_hash=$(sha256sum "$backup_file" | cut -d' ' -f1)
    
    cat > "$metadata_file" << EOF
{
  "backup_file": "$(basename "$backup_file")",
  "backup_type": "$backup_type",
  "timestamp": "$timestamp",
  "created_at": "$(date -Iseconds)",
  "file_size": $file_size,
  "file_hash": "$file_hash",
  "encrypted": $([ "${ENCRYPT_BACKUPS:-false}" == "true" ] && echo "true" || echo "false"),
  "version": "3.0",
  "hostname": "$(hostname)",
  "user": "$(whoami)"
}
EOF
    
    log_info "Metadatos creados para $(basename "$backup_file")"
}

# Restaurar backup
restore_backup() {
    local backup_file="$1"
    local force="${2:-false}"
    
    if [[ ! -f "$backup_file" ]]; then
        log_error "Archivo de backup no encontrado: $backup_file"
        return 1
    fi
    
    # Verificar si est√° encriptado
    local temp_backup="$backup_file"
    if [[ "$backup_file" =~ \.enc$ ]]; then
        temp_backup="/tmp/backup_decrypt_$$.tar.gz"
        if ! decrypt_backup "$backup_file" "$temp_backup"; then
            return 1
        fi
    fi
    
    # Verificar checksum si existe
    if [[ "${CHECKSUM_VALIDATION:-true}" == "true" ]]; then
        verify_checksum "$temp_backup" || {
            log_error "Verificaci√≥n de checksum fallida"
            [[ "$temp_backup" != "$backup_file" ]] && rm -f "$temp_backup"
            return 1
        }
    fi
    
    # Crear backup de la configuraci√≥n actual antes de restaurar
    if [[ "$force" != "true" ]] && [[ -f "$CONFIG_DIR/config.conf" ]]; then
        log_info "Creando backup de seguridad antes de restaurar"
        create_backup "pre_restore" >/dev/null
    fi
    
    # Restaurar
    if tar -xzf "$temp_backup" -C "$CONFIG_DIR" 2>/dev/null; then
        log_success "Backup restaurado exitosamente"
        notify "‚úÖ Restore Completado" "Configuraci√≥n restaurada desde backup" "document-revert"
        
        # Limpiar archivo temporal si se cre√≥
        [[ "$temp_backup" != "$backup_file" ]] && rm -f "$temp_backup"
        
        return 0
    else
        log_error "Error restaurando backup"
        notify "‚ùå Error de Restore" "Fallo al restaurar backup" "dialog-error"
        
        # Limpiar archivo temporal si se cre√≥
        [[ "$temp_backup" != "$backup_file" ]] && rm -f "$temp_backup"
        
        return 1
    fi
}

# Listar backups disponibles
list_backups() {
    local format="${1:-table}"
    
    echo -e "${BLUE}Backups Disponibles:${NC}"
    echo -e "${BLUE}===================${NC}"
    
    if [[ "$format" == "json" ]]; then
        echo "["
        local first=true
        for backup_file in "$BACKUP_DIR"/*.tar.gz "$BACKUP_DIR"/*.tar.gz.enc; do
            [[ ! -f "$backup_file" ]] && continue
            
            local metadata_file="${backup_file}.json"
            if [[ -f "$metadata_file" ]]; then
                [[ "$first" != "true" ]] && echo ","
                cat "$metadata_file"
                first=false
            fi
        done
        echo "]"
    else
        printf "%-25s %-12s %-20s %-10s\n" "Archivo" "Tipo" "Fecha" "Tama√±o"
        printf "%-25s %-12s %-20s %-10s\n" "-------" "----" "-----" "-------"
        
        for backup_file in "$BACKUP_DIR"/*.tar.gz "$BACKUP_DIR"/*.tar.gz.enc; do
            [[ ! -f "$backup_file" ]] && continue
            
            local basename_file=$(basename "$backup_file")
            local file_size=$(stat -c%s "$backup_file" 2>/dev/null | numfmt --to=iec || echo "N/A")
            local file_date=$(stat -c%y "$backup_file" 2>/dev/null | cut -d' ' -f1 || echo "N/A")
            
            # Extraer tipo del nombre del archivo
            local backup_type="manual"
            if [[ "$basename_file" =~ backup_([^_]+)_ ]]; then
                backup_type="${BASH_REMATCH[1]}"
            fi
            
            printf "%-25s %-12s %-20s %-10s\n" "$basename_file" "$backup_type" "$file_date" "$file_size"
        done
    fi
}

# Limpiar backups antiguos
cleanup_old_backups() {
    local retention_days="${BACKUP_RETENTION_DAYS:-30}"
    local max_backups="${MAX_BACKUPS:-30}"
    
    log_info "Iniciando limpieza de backups (retenci√≥n: $retention_days d√≠as, m√°ximo: $max_backups)"
    
    # Eliminar por fecha
    local deleted_by_date=0
    while IFS= read -r -d '' backup_file; do
        if [[ -f "$backup_file" ]]; then
            rm -f "$backup_file" "${backup_file}.json" "${backup_file}.sha256"
            ((deleted_by_date++))
            log_info "Backup eliminado por fecha: $(basename "$backup_file")"
        fi
    done < <(find "$BACKUP_DIR" -name "backup_*.tar.gz*" -mtime +"$retention_days" -print0 2>/dev/null)
    
    # Eliminar por cantidad (mantener solo los m√°s recientes)
    local backup_count=$(find "$BACKUP_DIR" -name "backup_*.tar.gz" -o -name "backup_*.tar.gz.enc" | wc -l)
    local deleted_by_count=0
    
    if [[ $backup_count -gt $max_backups ]]; then
        local to_delete=$((backup_count - max_backups))
        
        while IFS= read -r -d '' backup_file && [[ $deleted_by_count -lt $to_delete ]]; do
            if [[ -f "$backup_file" ]]; then
                rm -f "$backup_file" "${backup_file}.json" "${backup_file}.sha256"
                ((deleted_by_count++))
                log_info "Backup eliminado por cantidad: $(basename "$backup_file")"
            fi
        done < <(find "$BACKUP_DIR" -name "backup_*.tar.gz*" -printf '%T@ %p\0' 2>/dev/null | sort -zn | cut -d' ' -f2- -z)
    fi
    
    local total_deleted=$((deleted_by_date + deleted_by_count))
    if [[ $total_deleted -gt 0 ]]; then
        log_success "Limpieza completada: $total_deleted backups eliminados"
        notify "üßπ Limpieza de Backups" "$total_deleted backups antiguos eliminados" "user-trash"
    else
        log_info "Limpieza completada: no hay backups antiguos que eliminar"
    fi
}

# Backup autom√°tico programado
scheduled_backup() {
    local frequency="${BACKUP_FREQUENCY:-daily}"
    local last_backup_file="$CONFIG_DIR/.last_backup"
    local current_time=$(date +%s)
    
    # Determinar intervalo en segundos
    local interval_seconds
    case "$frequency" in
        "daily") interval_seconds=86400 ;;     # 24 horas
        "weekly") interval_seconds=604800 ;;   # 7 d√≠as
        "monthly") interval_seconds=2592000 ;; # 30 d√≠as
        *) interval_seconds=86400 ;;           # Default: daily
    esac
    
    # Verificar si es tiempo de hacer backup
    local should_backup=false
    
    if [[ ! -f "$last_backup_file" ]]; then
        should_backup=true
        log_info "Primer backup autom√°tico"
    else
        local last_backup_time=$(cat "$last_backup_file" 2>/dev/null || echo "0")
        local time_diff=$((current_time - last_backup_time))
        
        if [[ $time_diff -ge $interval_seconds ]]; then
            should_backup=true
            log_info "Tiempo para backup autom√°tico ($frequency)"
        fi
    fi
    
    if [[ "$should_backup" == "true" ]]; then
        if create_backup "auto_$frequency" >/dev/null; then
            echo "$current_time" > "$last_backup_file"
            log_success "Backup autom√°tico completado"
            
            # Limpiar backups antiguos
            cleanup_old_backups
        else
            log_error "Fallo en backup autom√°tico"
        fi
    else
        log_info "No es necesario hacer backup autom√°tico a√∫n"
    fi
}

# Verificar integridad de todos los backups
verify_all_backups() {
    local verified=0
    local failed=0
    
    echo -e "${BLUE}Verificando integridad de backups...${NC}"
    
    for backup_file in "$BACKUP_DIR"/*.tar.gz "$BACKUP_DIR"/*.tar.gz.enc; do
        [[ ! -f "$backup_file" ]] && continue
        
        local basename_file=$(basename "$backup_file")
        
        if [[ "${CHECKSUM_VALIDATION:-true}" == "true" ]]; then
            if verify_checksum "$backup_file"; then
                echo -e "${GREEN}‚úì${NC} $basename_file"
                ((verified++))
            else
                echo -e "${RED}‚úó${NC} $basename_file"
                ((failed++))
            fi
        else
            # Verificaci√≥n b√°sica: intentar listar contenido
            local temp_file="$backup_file"
            if [[ "$backup_file" =~ \.enc$ ]]; then
                temp_file="/tmp/verify_$$.tar.gz"
                if decrypt_backup "$backup_file" "$temp_file"; then
                    if tar -tzf "$temp_file" >/dev/null 2>&1; then
                        echo -e "${GREEN}‚úì${NC} $basename_file (desencriptado OK)"
                        ((verified++))
                    else
                        echo -e "${RED}‚úó${NC} $basename_file (archivo corrupto)"
                        ((failed++))
                    fi
                    rm -f "$temp_file"
                else
                    echo -e "${RED}‚úó${NC} $basename_file (error desencriptaci√≥n)"
                    ((failed++))
                fi
            else
                if tar -tzf "$backup_file" >/dev/null 2>&1; then
                    echo -e "${GREEN}‚úì${NC} $basename_file"
                    ((verified++))
                else
                    echo -e "${RED}‚úó${NC} $basename_file (archivo corrupto)"
                    ((failed++))
                fi
            fi
        fi
    done
    
    echo ""
    echo -e "${BLUE}Resumen de verificaci√≥n:${NC}"
    echo -e "${GREEN}Verificados: $verified${NC}"
    echo -e "${RED}Fallidos: $failed${NC}"
    
    if [[ $failed -gt 0 ]]; then
        log_error "Verificaci√≥n completada con $failed errores"
        return 1
    else
        log_success "Verificaci√≥n completada: todos los backups est√°n √≠ntegros"
        return 0
    fi
}

# Men√∫ interactivo
interactive_menu() {
    while true; do
        echo ""
        echo -e "${BLUE}=== Sistema de Backup v3.0 ===${NC}"
        echo -e "${BLUE}1.${NC} Crear backup manual"
        echo -e "${BLUE}2.${NC} Listar backups"
        echo -e "${BLUE}3.${NC} Restaurar backup"
        echo -e "${BLUE}4.${NC} Verificar integridad"
        echo -e "${BLUE}5.${NC} Limpiar backups antiguos"
        echo -e "${BLUE}6.${NC} Configurar backup autom√°tico"
        echo -e "${BLUE}7.${NC} Ver logs"
        echo -e "${BLUE}8.${NC} Salir"
        echo ""
        read -p "Selecciona una opci√≥n [1-8]: " choice
        
        case "$choice" in
            1)
                echo -e "${YELLOW}Creando backup manual...${NC}"
                if backup_file=$(create_backup "manual"); then
                    echo -e "${GREEN}Backup creado: $(basename "$backup_file")${NC}"
                fi
                ;;
            2)
                list_backups
                ;;
            3)
                echo -e "${YELLOW}Backups disponibles:${NC}"
                list_backups
                echo ""
                read -p "Ingresa el nombre del archivo de backup: " backup_name
                if [[ -n "$backup_name" ]]; then
                    backup_path="$BACKUP_DIR/$backup_name"
                    if [[ -f "$backup_path" ]]; then
                        read -p "¬øEst√°s seguro? Esto sobrescribir√° la configuraci√≥n actual [y/N]: " confirm
                        if [[ "$confirm" =~ ^[Yy]$ ]]; then
                            restore_backup "$backup_path"
                        fi
                    else
                        echo -e "${RED}Archivo no encontrado: $backup_path${NC}"
                    fi
                fi
                ;;
            4)
                verify_all_backups
                ;;
            5)
                read -p "¬øEst√°s seguro de limpiar backups antiguos? [y/N]: " confirm
                if [[ "$confirm" =~ ^[Yy]$ ]]; then
                    cleanup_old_backups
                fi
                ;;
            6)
                echo -e "${YELLOW}Configuraci√≥n actual de backup autom√°tico:${NC}"
                echo "Habilitado: ${BACKUP_ENABLED:-true}"
                echo "Frecuencia: ${BACKUP_FREQUENCY:-daily}"
                echo "Retenci√≥n: ${BACKUP_RETENTION_DAYS:-30} d√≠as"
                echo "Encriptaci√≥n: ${ENCRYPT_BACKUPS:-false}"
                echo ""
                echo "Para cambiar la configuraci√≥n, edita el archivo:"
                echo "$CONFIG_DIR/config.conf"
                ;;
            7)
                if [[ -f "$LOG_FILE" ]]; then
                    echo -e "${YELLOW}√öltimas 20 l√≠neas del log:${NC}"
                    tail -n 20 "$LOG_FILE"
                else
                    echo -e "${YELLOW}No hay logs disponibles${NC}"
                fi
                ;;
            8)
                echo -e "${GREEN}¬°Hasta luego!${NC}"
                exit 0
                ;;
            *)
                echo -e "${RED}Opci√≥n inv√°lida${NC}"
                ;;
        esac
        
        read -p "Presiona Enter para continuar..."
    done
}

# Funci√≥n principal
main() {
    # Crear directorios necesarios
    mkdir -p "$BACKUP_DIR" "$(dirname "$LOG_FILE")"
    
    case "${1:-}" in
        "create")
            backup_type="${2:-manual}"
            create_backup "$backup_type"
            ;;
        "restore")
            if [[ $# -lt 2 ]]; then
                echo -e "${RED}Error: Se requiere especificar el archivo de backup${NC}"
                echo "Uso: $0 restore <archivo_backup> [force]"
                exit 1
            fi
            restore_backup "$2" "${3:-false}"
            ;;
        "list")
            list_backups "${2:-table}"
            ;;
        "verify")
            verify_all_backups
            ;;
        "cleanup")
            cleanup_old_backups
            ;;
        "scheduled")
            scheduled_backup
            ;;
        "interactive")
            interactive_menu
            ;;
        *)
            echo -e "${BLUE}Sistema de Backup para Video Downloader v3.0${NC}"
            echo ""
            echo "Uso: $0 {create|restore|list|verify|cleanup|scheduled|interactive}"
            echo ""
            echo "Comandos:"
            echo "  create [tipo]       - Crear backup (manual, auto_daily, etc.)"
            echo "  restore <archivo>   - Restaurar desde backup"
            echo "  list [json]         - Listar backups disponibles"
            echo "  verify              - Verificar integridad de todos los backups"
            echo "  cleanup             - Limpiar backups antiguos"
            echo "  scheduled           - Ejecutar backup programado (para cron)"
            echo "  interactive         - Men√∫ interactivo"
            echo ""
            echo "Ejemplos:"
            echo "  $0 create manual"
            echo "  $0 list"
            echo "  $0 restore backup_manual_20250614_123456.tar.gz"
            echo "  $0 interactive"
            echo ""
            echo "Para configurar backup autom√°tico, agrega a crontab:"
            echo "0 2 * * * $0 scheduled  # Diario a las 2:00 AM"
            ;;
    esac
}

main "$@"

